from PySide2.QtWidgets import QSpacerItem, QSlider, QSizePolicy, QCheckBox, QTextEdit, QToolButton, QComboBox, QFrame, QHBoxLayout, QVBoxLayout, QWidget, QLabel, QLineEdit, QPushButton, QStatusBar, QFileDialog, QProgressBar, QMessageBox
from PySide2.QtCore import Signal, Qt, QFileInfo, QThread, QTimer
from PySide2 import QtCore, QtWidgets
import sys
import os
import hou, toolutils, shutil, time, json, re, threading, tempfile
from hou import FlipbookSettings, SceneViewer, paneTabType, qt
from PIL import Image, ImageDraw, ImageFont, ImageFile, ImageFilter
from os import path
import glob

class HoverButton(QPushButton):
    show_status_tip_signal = Signal(str)
    clear_status_tip_signal = Signal()
    clicked_emit_signal = Signal(int)

                    # text = status message will need to pass a variable in when showing a message. Order of __init__ matters
    def __init__(self, text, status_tip, parent = None):
        super().__init__(text, parent)
        self.setStatusTip(status_tip)

    def enterEvent(self, event):
        self.show_status_tip_signal.emit(self.statusTip())

    def leaveEvent(self, event):
        self.clear_status_tip_signal.emit()

    def mousePressEvent(self, event):
        super().mousePressEvent(event)
        self.clicked_emit_signal.emit(1)

class SaveDialog(QtWidgets.QFileDialog):
    def __init__(self, parent = None):
        super().__init__(parent)
        self.setAcceptMode(QtWidgets.QFileDialog.AcceptSave)
        self.setNameFilter("Hip File (*.hip)")

    def show_save_dialog(self):
        file_path = None
        if self.exec_() == QtWidgets.QFileDialog.Accepted:
            selected_files = self.selectedFiles()
            if selected_files:
                file_path = selected_files[0]

        return file_path

class FolderPathDialog(QWidget):
    folder_selected = Signal(str)

    def __init__(self, parent = None):
        super().__init__(parent)
        self.folder_path = None
        #self.destroyed.connect(self.show_folder_dialog)

    def show_folder_dialog(self, string_folder_path):
        folder_option = QFileDialog.Option()
        default_dir_path = hou.text.expandString("$HIP")
        while True:
            #init dialog options
            folder_dialog = QFileDialog()
            folder_dialog.setDirectory(default_dir_path)

            #fire dialog
            self.folder_path = folder_dialog.getExistingDirectory(self, "Set Folder Path", "", folder_option = folder_option)

            if folder_dialog.Accepted:
                if self.folder_path:
                    self.folder_selected.emit(self.folder_path)            
                    break
                break

            if not os.path.exists(string_folder_path):
                hou.ui.displayMessage("This is not a Valid Path")

            if len(string_folder_path) <= 0:
                message_reply = QMessageBox.question(self, "Confirmation", "There is no Folder Set. Do You Want to Continue Browsing?", 
                                                    QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
                if message_reply == QMessageBox.No:
                    QMessageBox.warning(self, "Warning", "Folder Path has not been Changed")
                    break
            
        return self.folder_path

class FfmpegFileBrowser(QWidget):
    file_selected = Signal(str)

    def __init__(self, parent = None):
        super().__init__(parent)
        self.file_path = None

    def show_file_dialog(self, path):
        file_option = QFileDialog.Option()
        default_hou_pref_path = hou.text.expandString("$HOUDINI_USER_PREF_DIR")
        while True:
            file_dialog = QFileDialog()
            file_dialog.setNameFilter("Ffmpeg Executable Files (ffmpeg.exe)")
            file_dialog.setDirectory(default_hou_pref_path)

            self.file_path, string_filter= file_dialog.getOpenFileName(self, "Set Ffmpeg Path", "", "Ffmpeg Executable Files (ffmpeg.exe)", options=file_option)
            if self.file_path:
                self.file_selected.emit(self.file_path)
                break
            
            if len(path <= 0) or not "ffmpeg.exe" in path:
                message_reply = QMessageBox.question(self, "Confirmation", "An ffmpeg.exe File is Required to Convert the Flipbooks to a Video. Do You Want to Continue Browsing?",
                                                    QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
                
                if message_reply == QMessageBox.No:
                    QMessageBox.warning(self, "Warning", "ffmpeg.exe Path not Selected. Make Sure You Set a Path to Enable the Video Conversion")
                    break

        return self.file_path

##########################################################################################################
# Progress Bar

class ProgressBarThread(QThread):
    update_progress = Signal(int)

    def __init__(self):
        super().__init__()
        self.file_list = []

    def run(self, folder_path, start_frame, end_frame):
        progress_completed = False
        progress_percentage = 0
        total_frames = int(end_frame - start_frame) + 1

        while True:
            current_file_list = os.listdir(folder_path)
            new_files = [file for file in current_file_list if file not in self.file_list]

            if new_files:
                progress_percentage = int(round(len(self.file_list) / total_frames) * 100)
                self.update_progress.emit(progress_percentage)

                self.file_list = current_file_list

            if progress_percentage == 100:
                break

        if progress_percentage == 100:
            progress_completed = True

        return progress_completed

##########################################################################################################
# Init before Tool Starts
def warn_user(self):
    reply = QMessageBox.warning(self, "Warning", "This Tool Requires an ffmpeg.exe file to Run the Video Conversion", QMessageBox.Ok, QMessageBox.Ok)

def check_if_new_file(self):
    if hou.hipFile.isNewFile():
        reply = QMessageBox.question(self, "Question", "This Tool Requires this File to be Saved First to Establish $HIP Variable.\nSave?",
                                    QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
        if reply == QMessageBox.Yes:
            try:
                save_dialog_widget = SaveDialog(self)
                file_path = save_dialog_widget.show_save_dialog()
                hou.hipFile.save(file_path)
            except hou.OperationFailed as e:
                QMessageBox.warning(self, "Warning", f"Failed to Save File", QMessageBox.Ok)
                sys.exit()
        else:
            sys.exit()

warn_user(self = None)

check_if_new_file(self = None)

#########################################################################################################
# Utility Stuff

class DummyCommands:

    video_formats = (".mp4", ".mov", ".avi")

    flipbook_image_formats = (".png", ".jpg", ".tiff", ".pic")

    hip_formats = ("hip", "hiplc", "hipnc")

    file_path = hou.hipFile.path()
    dir = path.dirname(file_path)
    ext = path.splitext(path.basename(file_path))[1]
    file_name = str(path.splitext(path.basename(file_path))[0])

    #file_no_version = file_name.split("_")[:-1]
    #file_no_version = "_".join(file_no_version)
    
    file_name_list = [item for item in file_name.split("_") if "v" not in item and any(char.isdigit() for char in item)]
    file_no_version = "_".join(file_name_list)

    def __init__(self):

        self.cur_flipbook_format = "pic"
        self.cur_video_format = "ffmpeg"

        self.flipbook_formats = ("pic", "png", "jpg", "tiff", )
        self.video_formats = ("mp4", "mov", "avi")

    def current_flipbook_format(self):
        return self.cur_flipbook_format

    def current_video_format(self):
        return self.cur_video_format
    
    def select_flipbook_format(self, flipbook_format):
        self.flipbook_formats = DummyCommands.flipbook_image_formats
        self.cur_flipbook_format = flipbook_format

    def select_video_format(self, video_format):
        self.video_formats = DummyCommands.video_formats
        self.cur_video_format = video_format

    def expand_hou_string(self, string):
        return hou.text.expandString(string)
    
    def get_json_path(self, line_edit):
        json_path = "/".join([line_edit, "flipbook_settings", "settings.json"])
        return str(json_path)
    
    @staticmethod   #this is a static method because it doesn't need to be an instance of the class
    def sort_reverse_combobox_key_function(item):
        return int(item[1:])

##########################################################################################################
# Save New Version or Current Commands       
    
    def scan_dir_for_files(self, directory, match_name, formats):
        all_h_files = []
        for hformat in formats:
            hfiles = glob.glob(directory+"/*.{}".format(hformat))
            for each_hfile in hfiles:
                if match_name in each_hfile:
                    all_h_files.append(each_hfile)

        return all_h_files

    def get_next_version(self, list_of_files):
        temp_ver = 0
        padzero = 0
        for file_path in list_of_files:
            file_name = str(path.splitext(path.basename(file_path))[0])
            if "v" in file_name and any(item.isdigit() for item in file_name):
                str_version = file_name.split("_")[1]

            str_version_list = str_version.split("v")[-1]
            #str_version = str(file_name.split["v"][-1])
            str_version = "".join(str_version_list)
            padzero = max(padzero, len(str_version))
            temp_ver = max(temp_ver, int(str_version))

        next_version = "{}".format(temp_ver + 1).zfill(padzero)

        return next_version

##########################################################################################################
# Main Window

class FlipBookerWindow(QWidget):
    def __init__(self, parent = None):
        super(FlipBookerWindow, self).__init__(parent)

        global window_x, window_y, new_window_y

        window_x = 800
        window_y = 220
        new_window_y = 500

        self.setWindowTitle("The One and Only FlipBooker")
        self.setGeometry(100, 100, window_x, window_y)
        self.setFixedSize(window_x, window_y)
        self.setWindowFlag(QtCore.Qt.WindowStaysOnTopHint, True)

        self.v_menu_layout = QVBoxLayout()
        self.camera_select_layout = QHBoxLayout()
        self.flip_book_save_layout = QHBoxLayout()
        self.start_end_frame_layout = QHBoxLayout()
        self.ffmpeg_layout = QHBoxLayout()
        self.checkbox_layout = QHBoxLayout()
        self.btn_layout = QHBoxLayout()
        self.button_checkbox_wrap_layout = QHBoxLayout()
        self.button_checkbox_wrap_layout.setAlignment(Qt.AlignLeft)

        self.text_option_layout = QHBoxLayout()
        self.text_option_layout.setAlignment(Qt.AlignLeft)

        self.camera_label = QLabel("Camera Path: ")
        self.flipbook_label = QLabel("FlipBook Save Path: ")
        self.video_save_label = QLabel("Video Save Path: ")
        self.ffmpeg_label = QLabel("Ffmpeg Path: ")

        self.text_multi_line_edit = QTextEdit()

        self.font_slider = QSlider()
        self.font_slider.setOrientation(Qt.Horizontal)
        self.font_slider.setMinimum(1)
        self.font_slider.setMaximum(100)
        self.font_slider.setValue(25)
        self.font_slider.setFixedWidth(250)
        self.font_slider.setHidden(True)
        self.font_slider_label = QLabel("Font Size:")
        self.font_slider_label.setHidden(True)
        self.font_value_label = QLabel("25")
        self.font_value_label.setFixedWidth(20)
        self.font_value_label.setAlignment(Qt.AlignCenter)
        self.font_value_label.setHidden(True)
        self.all_viewport_checkbox = QCheckBox()
        self.all_viewport_checkbox.setChecked(False)
        self.all_viewport_label = QLabel(" All Viewports:")

        [text_option_widget.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed) for text_option_widget in [self.font_slider_label, self.font_slider,
                                                                                                           self.font_value_label, self.all_viewport_checkbox,
                                                                                                           self.all_viewport_label]]

        self.before_spacer = QSpacerItem(2, 0, QSizePolicy.Minimum, QSizePolicy.Fixed)
        self.after_spacer = QSpacerItem(2, 0, QSizePolicy.Minimum, QSizePolicy.Fixed)

        self.add_comment_checkbox_label = QLabel("Enable Commenting:")
        self.add_comment_checkbox = QCheckBox()
        self.auto_back_checkbox_label = QLabel("Auto Backup:")
        self.auto_back_checkbox = QCheckBox()

        [widget.setSizePolicy(QSizePolicy.Fixed, QSizePolicy.Fixed) for widget in [self.add_comment_checkbox_label, self.add_comment_checkbox,
                                                                                    self.auto_back_checkbox_label, self.auto_back_checkbox]]
        self.camera_line_edit = QLineEdit(self)
        
        self.video_line_edit = QLineEdit(self)

        self.flipbook_line_edit = QLineEdit(self)
        #self.flipbook_line_edit.setText("$HIP")

        self.ffmpeg_line_edit = QLineEdit(self)
        self.ffmpeg_line_edit.setText("$HOUDINI_USER_PREF_DIR/scripts/ffmpeg/bin/ffmpeg.exe")

        self.flipbook_format_select_combobox = QComboBox()
        self.video_format_select_combobox = QComboBox()
        self.ver_select_combobox = QComboBox()
        self.ver_select_combobox.setEnabled(False)

        self.flipbook_format_select_combobox.setFixedSize(80, 20)
        self.video_format_select_combobox.setFixedSize(80, 20)

        

########################################################################################
# Handle Line Widget Settings

        self.text_multi_line_edit.setText("[shotcam]\n'$F'/'$FEND'")
        #self.text_multi_line_edit.setPlaceholderText()
        #self.text_multi_line_edit.setStyleSheet()
        self.text_multi_line_edit.setDisabled(True)
        self.text_multi_line_edit.setHidden(True)

        self.add_comment_checkbox.setChecked(False)    #Fix this
        self.add_comment_checkbox.setCheckable(False)
        self.add_comment_checkbox.setHidden(True)
        self.add_comment_checkbox_label.setHidden(True)

        self.auto_back_checkbox.setChecked(True)

        self.ffmpeg_line_edit.setReadOnly(True)
        self.ffmpeg_line_edit.setFrame(QtWidgets.QFrame.NoFrame)
        self.ffmpeg_line_edit.setFocusPolicy(QtCore.Qt.NoFocus)

        self.flipbook_line_edit.setReadOnly(True)
        self.flipbook_line_edit.setFocusPolicy(QtCore.Qt.NoFocus)
        self.flipbook_line_edit.setFrame(QtWidgets.QFrame.NoFrame)
        #self.flipbook_line_edit.setStyleSheet("QLineEdit { selection-background-color: palette(window); }")
        
        self.video_line_edit.setReadOnly(True)
        self.video_line_edit.setFocusPolicy(QtCore.Qt.NoFocus)
        self.video_line_edit.setFrame(QtWidgets.QFrame.NoFrame)
        #self.video_line_edit.setStyleSheet("QLineEdit { selection-background-color: palette(window); }")

        self.flipbook_start_frame_label = QLabel("Start Frame: ")
        self.flipbook_end_frame_label = QLabel("End Frame: ")
        self.frame_rate_label = QLabel("FPS: ")
        self.name_label = QLabel("Name Prefix: ")

        self.flipbook_start_frame_line_edit = QLineEdit()
        #self.flipbook_start_frame_line_edit.setFocusPolicy(QtCore.Qt.NoFocus)
        self.flipbook_start_frame_line_edit.setFrame(QtWidgets.QFrame.NoFrame)

        self.flipbook_end_frame_line_edit = QLineEdit()
        #self.flipbook_end_frame_line_edit.setFocusPolicy(QtCore.Qt.NoFocus)
        self.flipbook_end_frame_line_edit.setFrame(QtWidgets.QFrame.NoFrame)

        self.fps_line_edit = QLineEdit()
        self.fps_line_edit.setFrame(QtWidgets.QFrame.NoFrame)

        self.name_line_edit = QLineEdit()
        self.name_line_edit.setFrame(QtWidgets.QFrame.NoFrame)

########################################################################################
# Separators

        self.seperator_cam = QFrame()
        self.seperator_cam.setFrameShape(QFrame.HLine)
        self.seperator_cam.setFrameShadow(QFrame.Sunken)

        self.seperator = QFrame()
        self.seperator.setFrameShape(QFrame.HLine)
        self.seperator.setFrameShadow(QFrame.Sunken)
        
        self.video_save_layout = QHBoxLayout()
        self.load_progress_bar = QProgressBar(self)
        self.status_bar = QStatusBar()
        
########################################################################################
# Create Buttons

        self.camera_node_chooser = hou.qt.NodeChooserButton() #NodeChooser("Choose Camera Path", self)
        self.camera_node_chooser.setAutoRaise(False)
        
        self.ffmpeg_browse_btn = HoverButton("Browse", "Find Ffmpeg.exe Location", self)

        self.launch_flip_book_btn = HoverButton("Launch FlipBook", "Start Houdini Flip Book For Camera Path", self)
        self.launch_flip_book_btn.setFixedSize(220, 20)

        self.convert_vid_btn = HoverButton("Encode FFMPEG", "Convert Flip Book Frames to Video Format of Your Choice", self)
        self.convert_vid_btn.setEnabled(False)
        self.convert_vid_btn.setFixedSize(220, 20)
        
        self.flip_book_browse_btn = HoverButton("Browse Save Path", "Browse Folder Directory to Save FlipBook Frame", self)
        self.flip_book_browse_btn.setFixedWidth(154)

        self.version_up_btn = HoverButton("Version Up", "Increment Version for Flipbook Directory", self)
        self.version_up_btn.setFixedHeight(20)
        self.version_up_btn.setEnabled(False)

########################################################################################
# Connect Buttons

        self.ffmpeg_browse_btn.show_status_tip_signal.connect(self.update_status_tip)
        self.ffmpeg_browse_btn.clear_status_tip_signal.connect(self.clear_status_tip)
        self.ffmpeg_browse_btn.clicked.connect(self.ffmpeg_show_file_dialog)

        self.launch_flip_book_btn.show_status_tip_signal.connect(self.update_status_tip)
        self.launch_flip_book_btn.clear_status_tip_signal.connect(self.clear_status_tip)
        self.launch_flip_book_btn.clicked.connect(self.run_flipbook)
        #self.launch_flip_book_btn.clicked_emit_signal.connect(self.call_progress_bar(str(self.flipbook_line_edit.text())))

        self.convert_vid_btn.show_status_tip_signal.connect(self.update_status_tip)
        self.convert_vid_btn.clear_status_tip_signal.connect(self.clear_status_tip)

        self.flip_book_browse_btn.show_status_tip_signal.connect(self.update_status_tip)
        self.flip_book_browse_btn.clear_status_tip_signal.connect(self.clear_status_tip)
        self.flip_book_browse_btn.clicked.connect(self.flipbook_show_folder_dialog)

        self.version_up_btn.show_status_tip_signal.connect(self.update_status_tip)
        self.version_up_btn.clear_status_tip_signal.connect(self.clear_status_tip)
        self.version_up_btn.clicked.connect(self.version_up_mk_dir)

        self.camera_node_chooser.setNodeChooserFilter(hou.nodeTypeFilter.ObjCamera)
        self.camera_node_chooser.nodeSelected.connect(self.update_camera_line_edit)
        #self.camera_node_chooser.clear_status_tip_signal.connect(self.clear_status_tip)

        self.name_line_edit.editingFinished.connect(self.update_name(name="$HIPNAME"))

        self.flipbook_start_frame_line_edit.editingFinished.connect(self.update_start_frame(start_frame="$RFSTART"))
        
        self.flipbook_end_frame_line_edit.editingFinished.connect(self.update_end_frame(end_frame="$RFEND"))

        self.fps_line_edit.editingFinished.connect(self.update_fps(fps="$FPS"))

        self.ffmpeg_line_edit.textChanged.connect(self.check_enabled)
        self.flipbook_line_edit.textChanged.connect(self.check_save_flipbook_enabled)

        self.add_comment_checkbox.stateChanged.connect(self.toggle_text_edit)

        self.all_viewport_checkbox.stateChanged.connect(self.update_all_viewport_checkbox)

        #Autosave multiline edit
        self.text_multi_line_edit.textChanged.connect(self.stop_timer_on_edit)

        self.font_slider.valueChanged.connect(self.update_font_value)

        self.timer = QTimer(self)
        #self.timer.setSingleShot(True)
        self.timer.timeout.connect(self.process_on_text_change)
########################################################################################
# Add Widgets to Menu

        self.ffmpeg_layout.addWidget(self.ffmpeg_label)
        self.ffmpeg_layout.addWidget(self.ffmpeg_line_edit)
        self.ffmpeg_layout.addWidget(self.ffmpeg_browse_btn)

        self.start_end_frame_layout.addWidget(self.name_label)
        self.start_end_frame_layout.addWidget(self.name_line_edit)
        self.start_end_frame_layout.addWidget(self.flipbook_start_frame_label)
        self.start_end_frame_layout.addWidget(self.flipbook_start_frame_line_edit)
        self.start_end_frame_layout.addWidget(self.flipbook_end_frame_label)
        self.start_end_frame_layout.addWidget(self.flipbook_end_frame_line_edit)
        self.start_end_frame_layout.addWidget(self.frame_rate_label)
        self.start_end_frame_layout.addWidget(self.fps_line_edit)

        self.camera_select_layout.addWidget(self.camera_label)
        self.camera_select_layout.addWidget(self.camera_line_edit)
        self.camera_select_layout.addWidget(self.camera_node_chooser)

        self.flip_book_save_layout.addWidget(self.flipbook_label)
        self.flip_book_save_layout.addWidget(self.flipbook_line_edit)
        self.flip_book_save_layout.addWidget(self.flipbook_format_select_combobox)
        self.flip_book_save_layout.addWidget(self.flip_book_browse_btn)

        self.video_save_layout.addWidget(self.video_save_label)
        self.video_save_layout.addWidget(self.video_line_edit)
        self.video_save_layout.addWidget(self.video_format_select_combobox)
        self.video_save_layout.addWidget(self.version_up_btn)
        self.video_save_layout.addWidget(self.ver_select_combobox)

        self.btn_layout.addWidget(self.launch_flip_book_btn)
        self.btn_layout.addWidget(self.convert_vid_btn)

        self.checkbox_layout.addWidget(self.add_comment_checkbox_label)
        self.checkbox_layout.addWidget(self.add_comment_checkbox)
        self.checkbox_layout.addWidget(self.auto_back_checkbox_label)
        self.checkbox_layout.addWidget(self.auto_back_checkbox)
        self.checkbox_layout.addItem(self.before_spacer)
        self.checkbox_layout.addWidget(self.all_viewport_label)
        self.checkbox_layout.addItem(self.after_spacer)
        self.checkbox_layout.addWidget(self.all_viewport_checkbox)

        self.button_checkbox_wrap_layout.addLayout(self.btn_layout)
        self.button_checkbox_wrap_layout.addLayout(self.checkbox_layout)

        self.text_option_layout.addWidget(self.font_slider_label)
        self.text_option_layout.addWidget(self.font_value_label)
        self.text_option_layout.addWidget(self.font_slider)
        
########################################################################################
# Add to Layout

        self.v_menu_layout.addLayout(self.camera_select_layout)

        self.v_menu_layout.addLayout(self.ffmpeg_layout)

        self.v_menu_layout.addWidget(self.seperator_cam)

        self.v_menu_layout.addLayout(self.start_end_frame_layout)

        self.v_menu_layout.addLayout(self.flip_book_save_layout)
        self.v_menu_layout.addLayout(self.video_save_layout)
        self.v_menu_layout.addLayout(self.text_option_layout)
        self.v_menu_layout.addWidget(self.text_multi_line_edit)
        self.v_menu_layout.addWidget(self.seperator)
        
        self.v_menu_layout.addWidget(self.load_progress_bar)
        self.v_menu_layout.addLayout(self.button_checkbox_wrap_layout)
        self.v_menu_layout.addWidget(self.status_bar)

        self.setLayout(self.v_menu_layout)

########################################################################################
# Establish Instances

        self.folder_dialog_widget = None

        self.ffmpeg_file_dialog_widget = None

        self.flipbook_video_format_selector = DummyCommands()

        self.initial_text = self.text_multi_line_edit.toPlainText()

        self.has_been_toggled = False

        self.instance_sort = None

        self.last_text = self.text_multi_line_edit.toPlainText()

        self.last_font_size = self.font_slider_label.text()

        self.last_all_viewport_check = self.all_viewport_checkbox.isChecked()

        #self.thread = None

########################################################################################
# ComboBox add Items

        self.flipbook_format_select_combobox.addItems(self.flipbook_video_format_selector.flipbook_formats)
        self.flipbook_format_select_combobox.activated.connect(self.flipbook_format_selected)

# Video Conversion ComboBox add Items
        
        self.video_format_select_combobox.addItems(self.flipbook_video_format_selector.video_formats)
        self.video_format_select_combobox.activated.connect(self.video_format_selected)

# Version Selection Items
        self.ver_select_combobox.activated.connect(self.flipbook_ver_selected)

########################################################################################
# Update Status Tips and Font Label Value

    def update_status_tip(self, text):
        self.status_bar.showMessage(text)

    def clear_status_tip(self):
        self.status_bar.clearMessage()

    def update_font_value(self, value):
        self.font_value_label.setText("{}".format(value))
        
        cur_font_size = self.font_value_label.text()
        print("new value: {}".format(cur_font_size))

        if self.last_font_size != cur_font_size and self.add_comment_checkbox.isChecked():
            self.timer.singleShot(500, self.comment_on_text_change)
            print("starting update font size timer")
        else:
            self.timer.stop()

        return value
    
    def update_all_viewport_checkbox(self):
        
        cur_last_all_viewport_check = self.all_viewport_checkbox.isChecked()
        print("new viewport checkbox state: {}".format(cur_last_all_viewport_check))

        if self.last_all_viewport_check != cur_last_all_viewport_check:
            self.timer.singleShot(500, self.comment_on_text_change)
            print("starting update all viewport checkbox timer")
        else:
            self.timer.stop()

########################################################################################
# Button Enabling

    def check_save_flipbook_enabled(self, text):
        has_path = True if os.path.exists(text) else False

        if has_path:
            self.add_comment_checkbox.setCheckable(True)
            self.add_comment_checkbox.setHidden(False)
            self.add_comment_checkbox_label.setHidden(False)
        else:
            self.add_comment_checkbox.setCheckable(False)
            self.add_comment_checkbox.setHidden(True)
            self.add_comment_checkbox_label.setHidden(True)

    def check_enabled(self):
        ffmpeg_text = os.path.expanduser((hou.text.expandString(self.ffmpeg_line_edit.text())))
        check_string = "ffmpeg.exe"
        has_ffmpeg = True if check_string in ffmpeg_text else False
        path_to_eval = self.update_flipbook_combobox()
        has_ver = True if len(path_to_eval) > 0 else False

        self.convert_vid_btn.setEnabled(has_ffmpeg)
        self.ver_select_combobox.setEnabled(has_ver)

        if os.path.exists(self.flipbook_line_edit.text()):
            self.add_comment_checkbox.setEnabled(True)
            self.add_comment_checkbox.setCheckable(True)
            self.version_up_btn.setEnabled(True)
            
        else:
            self.add_comment_checkbox.setEnabled(False)
            self.add_comment_checkbox.setCheckable(False)
            self.version_up_btn.setEnabled(False)

    def toggle_text_edit(self, state):
        
        settings_file = self.flipbook_video_format_selector.get_json_path(self.flipbook_line_edit.text())
        print(settings_file)

        info, tempdir = self.read_json_settings(settings_file)

        if self.has_been_toggled is False:
            if state == 2:
                self.text_multi_line_edit.setText(info['comment_text'])
                self.text_multi_line_edit.setDisabled(False)
                self.text_multi_line_edit.setHidden(False)
                self.font_slider.setHidden(False)
                self.font_slider_label.setHidden(False)
                self.font_value_label.setHidden(False)
                self.setFixedHeight(new_window_y)
                self.has_been_toggled = True
            else:
                self.text_multi_line_edit.setDisabled(True)
                self.text_multi_line_edit.setHidden(True)
                self.font_slider.setHidden(True)
                self.font_slider_label.setHidden(True)
                self.font_value_label.setHidden(True)
                self.setFixedHeight(window_y)
        else:
            if state == 2:
                self.text_multi_line_edit.setDisabled(False)
                self.text_multi_line_edit.setHidden(False)
                self.font_slider.setHidden(False)
                self.font_slider_label.setHidden(False)
                self.font_value_label.setHidden(False)
                self.setFixedHeight(new_window_y)
                self.text_multi_line_edit.setPlainText(self.initial_text)

            else:
                self.text_multi_line_edit.setDisabled(True)
                self.text_multi_line_edit.setHidden(True)
                self.font_slider.setHidden(True)
                self.font_slider_label.setHidden(True)
                self.font_value_label.setHidden(True)
                self.setFixedHeight(window_y)
                self.initial_text = self.text_multi_line_edit.toPlainText()

########################################################################################
# Handle ComboBox Selections

    def flipbook_format_selected(self, index):
        flipbook_format = self.flipbook_format_select_combobox.currentText()

        self.flipbook_video_format_selector.select_flipbook_format(flipbook_format)

        print("Current Seleted Flipbook Format: {}".format(flipbook_format))    #Debug

    def video_format_selected(self, index):
        video_format = self.video_format_select_combobox.currentText()
        self.flipbook_video_format_selector.select_video_format(video_format)

        print("Current Selected Video Format: {}".format(video_format))

########################################################################################
# Folder Dialog for FlipBook

    def flipbook_show_folder_dialog(self):
        print("Running Folder Dialog")
        string_folder_path = hou.text.expandString(self.flipbook_line_edit.text())

        if self.folder_dialog_widget is None:
            self.folder_dialog_widget = FolderPathDialog(self)
            self.folder_dialog_widget.folder_selected.connect(self.flipbook_get_folder_selected)
            
            #Cleanup
            self.folder_dialog_widget.destroyed.connect(self.flipbook_reset_folder_dialog_widget)

        self.folder_dialog_widget.show_folder_dialog(string_folder_path)

        return self.folder_dialog_widget.folder_path

    def flipbook_get_folder_selected(self, folder_path_text):
        print("Handling Flip Book Path")
        init_dir = "/".join([folder_path_text, "flipbook"])
        print("init_dir is: {}".format(init_dir))
        init_path = "/".join([init_dir, "v1"])
        print("init_path is {}".format(init_path))
        ver_num_list = list()
        max_ver_num = 1
        output_path = init_path

        if os.path.exists(init_path):
            path_list = os.listdir(init_dir)    #change to list comprehension
            if len(path_list) > 0:

                ver_num_list = [int(digit[1:]) for digit in path_list]
                print("Version Numbers Available: {}".format(ver_num_list))

                max_ver_num = max(ver_num_list)
                print("max version number: {}".format(max_ver_num))

                max_ver_num = max(ver_num_list)

                output_path = "".join([init_dir, "/", "".join(["v", str(max_ver_num)])])

            if os.path.exists(output_path):
                reply = QMessageBox.question(self, "Confirmation", "This Directory Already Has an Existing Heirarchy. Do you want to Version Up?",
                                            QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
                if reply == QMessageBox.Yes:
                    dir_path, max_ver_num = self.version_up_dir_callback(output_path)
                    self.make_new_dir(dir_path)
                    use_new_dir = True
                if reply == QMessageBox.No:
                    dir_path = output_path
                    print("Reading JSON file from QMessage Box No Option with dir path being: {}".format(dir_path))    #Debug
                    info, tempdir = self.read_json_settings(self.flipbook_video_format_selector.get_json_path(dir_path))
                    use_new_dir = False

        else:

            dir_list = init_path.split("/")
            print("dir list: {}".format(dir_list))  #Debug

            folder_list = folder_path_text.split("/")
            print("folder list: {}".format(folder_list))    #Debug

            #cant use set difference because order matters :(
            new_list = [item for item in dir_list if item not in folder_list]        
            print("list with difference: {}".format(new_list))    #Debug

            new_dir = str()

            for directory in new_list:
                if directory not in folder_list:
                    new_dir = "".join([folder_path_text, "/", directory])
                    print("Creating Intermittent Dirs: {}".format(new_dir))    #Debug
                    if not os.path.exists(new_dir):
                        folder_path_text = new_dir
                        os.mkdir(folder_path_text)
                    else:
                        folder_path_text = new_dir
            
            self.save_json_settings(folder_path_text)
            json_path = self.flipbook_video_format_selector.get_json_path(folder_path_text)
            info, tempdir = self.read_json_settings(json_path)
            output_path = init_path

        self.update_flipbook_video_line_edit(output_path)
        self.update_flipbook_combobox()
        self.check_enabled()
        self.ver_select_combobox.setCurrentIndex(int(max_ver_num) - 1)

        settings_file = self.flipbook_video_format_selector.get_json_path(self.flipbook_line_edit.text())

        print("JSON settings file located in: {}".format(settings_file))    #Debug

        return folder_path_text
        
    def flipbook_reset_folder_dialog_widget(self):
        print("Destroying Dialog")  #Debug
        if self.folder_dialog_widget is not None:
            #self.folder_dialog_widget.folder_selected.disconnect(self.flipbook_get_folder_selected)
            self.folder_dialog_widget = None

########################################################################################
# Handle JSON file for Flipbook Settings

    def save_json_settings(self, json_save_path):
        print("Saving JSON Flipbook Settings")  #Debug

        default_path = json_save_path

        settings_dir = "".join([default_path,"/flipbook_settings/"])
        settings_file_name = "settings.json"
        settings_file = "".join([settings_dir, settings_file_name])

        if not os.path.exists(settings_dir):
            os.mkdir(settings_dir)
            with open(settings_file, 'w') as file:
                info = {"video_format": "mp4",
                        "start_frame": "$RFSTART",
                        "end_frame": "$RFEND",
                        "all_viewports": False,
                        "auto_backup": True,
                        "comment": True,
                        "font_size":25,
                        "sys_font_path": "C:\\Windows\\Fonts\\arialbd.ttf",
                        "custom_font": False,
                        "comment_text": "[shotcam]\n'$F'/'$FEND'",
                        "width": 500,
                        "height": 300,
                        }
            
                file.write(json.dumps(info, indent=4))
                file.close

        return settings_file

    def read_json_settings(self, settings_file):
        # Fetch Data if it already Exists
        #settings_file = json_path  #json_path is the original method provided variable added
        
        print("read json settings path: {}".format(settings_file))        
        
        try:
            if os.path.exists(settings_file):
                settings_file = settings_file
            else:
                print("Could not find global settings file variable, using explicit settings instead")
                cur_ver = self.ver_select_combobox.currentText()
                path_list = self.flipbook_line_edit.text().split("/")
                path_list.pop(-1)
                print("path list is: {}".format(path_list)) #Debug
                path_concat = "/".join(path_list)
                file_dir = "/".join([path_concat, cur_ver])
                
                settings_file = "/".join([file_dir, "flipbook_settings", "settings.json"])
                print("File Dir for Reading JSON is: {}".format(settings_file)) #Debug
        except Exception as e:
            print("Exception error:\n{}".format(e))

        info = dict()

        if os.path.exists(settings_file):
            with open(settings_file, 'r') as file:
                info = json.loads(file.read())
                print("Reading JSON File...")
                file.close()

        #establish global variables for all settings

        #global video_format, start_frame, end_frame, all_viewports, auto_back, comment, font_size, sys_font_path, custom_font, comment_text, width, height
        '''
        video_format = info['video_format']
        start_frame = info['start_frame']
        end_frame = info["end_frame"]
        all_viewports = info["all_viewports"]
        auto_back = info["auto_backup"]
        comment = info["comment"]
        font_size = info["font_size"]
        sys_font_path = info["sys_font_path"]
        custom_font = info["custom_font"]
        comment_text = info["comment_text"]
        width = info["width"]
        height = info["height"]

        video_format = video_format[0]
        '''
        name = hou.text.expandString(self.name_line_edit.text())

        #create temp directory for text
        tempdir = tempfile.gettempdir()
        temp_path = os.path.join(tempdir, 'flipbook_temp')
        if not os.path.exists(temp_path):
            os.mkdir(temp_path)

        #get actual directory path
        hip_path = hou.text.expandString('$HIP')
        input_path = "".join([hip_path, "/flipbook/"])

        input_path = "".join([hou.text.expandString(self.flipbook_line_edit.text()), "/", "video_output"])

        if not os.path.exists(input_path):
            os.mkdir(input_path)
        #create backup directory
        input_path_bk = "".join([input_path, "_bk/"])
        if not os.path.exists(input_path_bk):
            os.mkdir(input_path_bk)

        return info, tempdir
        
    def overwrite_existing_json_text(self):

        self.comment_on_text_change()   #start recursive time check

        code_executed = False

        settings_file = self.flipbook_video_format_selector.get_json_path(self.flipbook_line_edit.text())

        with open(settings_file, "r") as file:
            existing_data = json.loads(file.read())
            file.close()

        updates = {"video_format": self.video_format_select_combobox.currentText(),
                   "start_frame": self.flipbook_start_frame_line_edit.text(),
                   "end_frame": self.flipbook_end_frame_line_edit.text(),
                   "all_viewports": True if self.all_viewport_checkbox.isChecked() else False,
                   "auto_backup": True if self.auto_back_checkbox.isChecked() else False,
                   "comment": True if self.add_comment_checkbox.isChecked() else False,
                   "font_size": int(self.font_value_label.text().replace(" ", "")),
                   "sys_font_path": "C:\\Windows\\Fonts\\arialbd.ttf",
                   "custom_font": False,
                   "comment_text": self.text_multi_line_edit.toPlainText(),
                   "width": 500,
                   "height": 300,
                   }

        code_executed = True

        if code_executed:
            for key, new_value in updates.items():
                if key in existing_data and existing_data[key] != new_value:
                    existing_data[key] = new_value

        with open(settings_file, 'w') as file:
            file.write(json.dumps(existing_data, indent=4))
            file.close()

        self.read_json_settings(settings_file)

    def stop_timer_on_edit(self):
        cur_text = self.text_multi_line_edit.toPlainText()
        
        if self.last_text != cur_text and self.add_comment_checkbox.isChecked():
            self.timer.singleShot(500, self.comment_on_text_change)
            print("starting timer")    #Debug
        else:
            self.timer.stop()

    def comment_on_text_change(self):
        self.timer.start(3000)     #how long to autosave in miliseconds

    def process_on_text_change(self):
        current_text = self.text_multi_line_edit.toPlainText()
        cur_font_size = self.font_value_label.text()
        cur_last_all_viewport_check = self.all_viewport_checkbox.isChecked()
        try:
            if current_text != self.last_text:
                self.overwrite_existing_json_text()
                self.status_bar.showMessage("Saving New JSON Settings", 3000)    #show status message for how long in miliseconds
            if cur_font_size != self.last_font_size:
                self.overwrite_existing_json_text()
                self.status_bar.showMessage("Saving New JSON Settings", 3000)    #show status message for how long in miliseconds
            if cur_last_all_viewport_check != self.last_all_viewport_check:
                self.overwrite_existing_json_text()
                self.status_bar.showMessage("Saving New JSON Settings", 3000)    #show status message for how long in miliseconds
        except Exception as e:
            self.timer.stop()
            print("Exception error debug:\n{}".format(e))

        self.last_text = current_text
        self.last_font_size = cur_font_size
        self.last_all_viewport_check = cur_last_all_viewport_check
        print("last text is now set to: {}".format(self.last_text))
        self.timer.stop()
        print("Keeping original text")
        
########################################################################################
# Handle Version Combo Box

    def flipbook_ver_selected(self, index):
        cur_ver = self.ver_select_combobox.currentText()
        print("current combobox select: {}".format(cur_ver))    #Debug

        path_list = self.flipbook_line_edit.text().split("/")
        path_list.pop(-1)
        print("path list: {}".format(path_list))    #Debug
        
        path_reconstructed = "/".join(path_list)
        path_reconstructed_w_ver = "/".join([path_reconstructed, cur_ver])
        print("path reconstructed: {}".format(path_reconstructed_w_ver))    #Debug

        json_cur_path = "/".join([path_reconstructed_w_ver, "flipbook_settings", "settings.json"])

        self.flipbook_line_edit.setText(path_reconstructed_w_ver)
        self.video_line_edit.setText("/".join([path_reconstructed_w_ver, "video_output"]))

        settings_file = self.flipbook_video_format_selector.get_json_path(self.flipbook_line_edit.text())

        info, tempdir = self.read_json_settings(settings_file)
        #self.check_enabled()   #Come back to this later

        self.text_multi_line_edit.setText(info["comment_text"])
        self.font_slider.setValue(info['font_size'])
        self.all_viewport_checkbox.setChecked(info['all_viewports'])
        self.auto_back_checkbox.setChecked(info['auto_backup'])

        return cur_ver

    def update_flipbook_combobox(self):
        path_to_eval_list = self.flipbook_line_edit.text().split("/")
        path_to_eval_list.pop(-1)
        path_to_eval = "/".join(path_to_eval_list)
        cur_ver_list = os.listdir(path_to_eval)

        if self.instance_sort is None:
            self.instance_sort = self.flipbook_video_format_selector
            sorted_ver_list = sorted(cur_ver_list, key=self.instance_sort.sort_reverse_combobox_key_function)
            self.instance_sort = None

            print("instance sort after sorting: {}".format(self.instance_sort))    #Debug

        self.ver_select_combobox.clear()
        self.ver_select_combobox.addItems(sorted_ver_list)

        return cur_ver_list
    
########################################################################################
# Version Up Directories assuming flipbook path has been set

    def version_up_dir_callback(self, folder_path):
        if os.path.exists(self.flipbook_line_edit.text()):
            cur_path = self.flipbook_line_edit.text()
        else:
            cur_path = folder_path
        print("cur path to eval: {}".format(cur_path))  #Debug

        dir_split = cur_path.split("/")
        dir_split.pop(-1)

        dir_path = "/".join(dir_split)
        dir_list = os.listdir(dir_path)
        print("dir list in version up callback: {}".format(dir_list))   #Debug

        ver_num_list = [int(digit[1:]) for digit in dir_list if digit[1:].isdigit()]

        ver_num_list_sorted = sorted(ver_num_list, reverse=True)

        #individual_string_list = [single for items in dir_list for single in list(items)]
        #print("list seperated into single characters: {}".format(individual_string_list))   #Debug

        #ver_num_list = [int(i) for i in individual_string_list if isinstance(i, (int, str)) and i.isdigit()]
        #print("ver num list: {}".format(ver_num_list))  #Debug

        max_ver_num = int(max(ver_num_list))
        print("max version number: {}".format(max_ver_num)) #Debug
        
        result = max_ver_num + 1
        print("ver num increased to: {}".format(result))   #Debug

        folder_path_text = "".join([dir_path, "/", "".join(["v", str(result)])])
        print(folder_path_text)    #Debug
        return folder_path_text, result
        
    def make_new_dir(self, dir_path):
        os.mkdir(dir_path)
        return dir_path

    def version_up_mk_dir(self):
        dir_to_ver_up = self.flipbook_line_edit.text()

        change_flipbook_line, ver_num = self.version_up_dir_callback(dir_to_ver_up)
        self.make_new_dir(change_flipbook_line)
        
        self.flipbook_line_edit.setText(change_flipbook_line)

        change_vid_line = "".join([change_flipbook_line, "/", "video_output"])
        self.video_line_edit.setText(change_vid_line)

        settings_file = self.flipbook_video_format_selector.get_json_path(self.flipbook_line_edit.text())

        self.save_json_settings(change_flipbook_line)
        info, tempdir = self.read_json_settings(settings_file)
        self.update_flipbook_combobox()

        items = [self.ver_select_combobox.itemText(item) for item in range(self.ver_select_combobox.count())]
        
        print("Current Items Existing in Version Select Combo Box: {}".format(items))    #Debug

        item_version = "".join(["v", str(ver_num)])

        item_index_to_set = self.ver_select_combobox.findText(item_version)

        self.ver_select_combobox.setCurrentIndex(item_index_to_set)

########################################################################################
# File Dialog for FFMPEG

    def ffmpeg_show_file_dialog(self):
        print("Running ffmpeg File Dialog")    #Debug
        path = hou.text.expandString(self.ffmpeg_line_edit.text())
        if self.ffmpeg_file_dialog_widget is None:
            self.ffmpeg_file_dialog_widget = FfmpegFileBrowser(self)
            self.ffmpeg_file_dialog_widget.file_selected.connect(self.ffmpeg_selected)

            self.ffmpeg_file_dialog_widget.destroyed.connect(self.ffmpeg_reset_dialog_widget)
        
        self.ffmpeg_file_dialog_widget.show_file_dialog(path)

        return self.ffmpeg_file_dialog_widget.file_path

    def ffmpeg_selected(self, ffmpeg_path_text):
        print("Handling ffmpeg Path")    #Debug
        self.ffmpeg_line_edit.setText(ffmpeg_path_text)
        self.ffmpeg_line_edit.setCursorPosition(len(ffmpeg_path_text))

    def ffmpeg_reset_dialog_widget(self):
        print("Resetting ffmpeg Dialog")    #Debug
        if self.ffmpeg_file_dialog_widget is not None:
            self.ffmpeg_file_dialog_widget = None

########################################################################################
# Update Line Edit Text

    def update_camera_line_edit(self, node):
        print("Firing Update Camera")   #Debug
        self.camera_line_edit.setText(node.path())

    def update_start_frame(self, start_frame):
        print("Modifying Start Frame to: {}".format(start_frame))   #Debug
        self.flipbook_start_frame_line_edit.setText(str(start_frame))

    def update_end_frame(self, end_frame):
        print("Modifying End Frame to: {}".format(end_frame))   #Debug
        self.flipbook_end_frame_line_edit.setText(str(end_frame))

    def update_fps(self, fps):
        print("Modifying FPS to: {}".format(fps))   #Debug
        self.fps_line_edit.setText(str(fps))
    
    def update_name(self, name):
        print("Modifying Flipbook and Video Name to: {}".format(name))  #Debug
        self.name_line_edit.setText(str(name))

    def update_flipbook_video_line_edit(self, line_edit):
        print("Modifying Flipbook Save Path to: {}".format(line_edit))  #Debug
        text = hou.text.expandString(line_edit)
        vid_text = "".join([text, "/", "video_output"])
        self.flipbook_line_edit.setText(text)
        self.flipbook_line_edit.setCursorPosition(len(text))

        self.video_line_edit.setText(vid_text)
        self.video_line_edit.setCursorPosition(len(vid_text))

        return text


########################################################################################
# Handle Camera Work and Flipbook

    def set_viewport_to_camera(self):
        print("Changing From Current Viewport to Specified Camera") #Debug
        
        swap_camera = hou.node(self.camera_line_edit.text())
        try:
        #cur_desktop = hou.ui.curDesktop()
            hou.ui.triggerUpdate()
            hou.ui.waitUntil(lambda: len(hou.node("/obj").children()) > 0)
            scene_view = toolutils.sceneViewer()
            viewport = scene_view.curViewport()
            viewport.setCamera(swap_camera)
            return True

        except Exception as e:
            print("Firing Exception")   #Debug
            reply = QMessageBox.warning(self, "Warning", "Target Camera Path is not Valid",
                                        QMessageBox.Ok)
            if reply == QMessageBox.Ok:
                self.camera_line_edit.clear()
                return False
        
        return swap_camera

    def swap_camera_to_run_flipbook_settings(self):
        
        code_executed = False
        self.set_viewport_to_camera()
        code_executed = True
        hou.ui.triggerUpdate()
        hou.ui.waitUntil(lambda: code_executed)

        self.flipbook_settings_after_ui_update()

        file_path = hou.text.expandString(self.flipbook_line_edit.text())
        
        print(file_path)

    def flipbook_settings_after_ui_update(self):
        
        json_path = self.flipbook_video_format_selector.get_json_path(self.flipbook_line_edit.text())

        info, tempdir = self.read_json_settings(json_path)

        all_viewports = info["all_viewports"]

        cur_desktop = hou.ui.curDesktop()
        scene_viewer = hou.paneTabType.SceneViewer
        scene = cur_desktop.paneTabOfType(scene_viewer)
        start_frame = int(hou.text.expandString(self.flipbook_start_frame_line_edit.text()))
        end_frame = int(hou.text.expandString(self.flipbook_end_frame_line_edit.text()))
        set_fps = float(hou.text.expandString(self.fps_line_edit.text()))
        
        file_path = self.flipbook_line_edit.text()
        file_name = hou.text.expandString(self.name_line_edit.text())
        frame = "$F4"
        padzero = 4
        ext = self.flipbook_format_select_combobox.currentText()

        cur_ver = self.ver_select_combobox.currentText()
        full_path = "".join([file_path, "/", file_name, "_", frame, ".", ext])
        full_tempdir_path = "".join([tempdir, "/", cur_ver, "/", file_name, "_", frame, ".", ext]).replace("\\", "/")
        
        hou.setFps(set_fps, modify_frame_count=True, preserve_keyframes=False, preserve_frame_start=False)

        flipbook_options = scene.flipbookSettings().stash()

        code_executed = False

        output_bool = True if os.path.exists(hou.text.expandString(self.flipbook_line_edit.text())) else False
        if output_bool:
            flipbook_options.output(full_path)
            print("Outputting Frames to: {}".format(full_path))

        flipbook_options.renderAllViewports(int(all_viewports))
        flipbook_options.useResolution(0)
        flipbook_options.frameRange((start_frame, end_frame))
        flipbook_options.cropOutMaskOverlay(1)
        flipbook_options.outputToMPlay(0)

        scene.flipbook(scene.curViewport(), flipbook_options)
        #hou.SceneViewer
        
        code_executed = True
        
        
        if code_executed:
            
            source_folder = self.flipbook_line_edit.text()
            destination_folder = os.sep.join([os.path.expanduser(tempdir), cur_ver]).replace("\\", "/")
            print("destination folder: {}".format(destination_folder))
            dest_list = destination_folder.split("/")
            cur_list_to_compare = os.path.expanduser(tempdir).split("/")
            missing_dir_list = [dir for dir in cur_list_to_compare if dir not in dest_list]
            print("Missing Directories: {}".format(missing_dir_list))
            
            if not os.path.exists(destination_folder):
                for directory in missing_dir_list:
                    new_dir = "".join([tempdir, directory])                
                    print("Creating Intermittent Temp Dir Directories: {}".format(new_dir))
                    os.mkdir(new_dir)
            
            self.copy_files_to_dir(source_folder, destination_folder)
        
    def copy_files_to_dir(self, source_folder, destination_folder):

        files = [file for file in os.listdir(source_folder) if os.path.isfile(os.path.join(source_folder, file))]

        for file in files:
            source_path = os.path.join(source_folder, file)
            destination_path = os.path.join(destination_folder, file)
            shutil.copyfile(source_path, destination_path)
            print("File Copying from Source: {} to Destination {}".format(source_path, destination_path))

    def run_flipbook(self):
        #run set to viewport to camera method
        options = DummyCommands()
        directory = str(options.dir)
        file_no_version = str(options.file_no_version)
        hip_formats = str(options.hip_formats)
        ext = str(options.ext)

        hfiles_in_dir = options.scan_dir_for_files(directory, file_no_version, hip_formats)
        next_version = options.get_next_version(hfiles_in_dir)

        pattern = r'v\d+'
        matched = re.search(pattern, hou.hipFile.basename())
        if matched:
            out_new_file = "{}_v{}{}".format(file_no_version, next_version, ext)
        else:
            out_new_file = "{}_{}{}".format(file_no_version, next_version, ext)

        out_current_file = "{}".format(hou.hipFile.basename())

        export_new_path = path.join(directory, out_new_file)
        export_current_path = path.join(directory, out_current_file)

        save_next_ver_to_flipbook_file = "".join([hou.text.expandString(self.flipbook_line_edit.text()), "/", next_version, ext])
        save_current_ver_to_flipbook_file = "".join([hou.text.expandString(self.flipbook_line_edit.text()), "/", hou.hipFile.basename()])

        message_box = QMessageBox()
        message_box.setText("You have Unsaved Changes. Do you want to Save before Running the Flipbook?")
        option_1 = message_box.addButton("Save Next Version", QMessageBox.AcceptRole)
        option_2 = message_box.addButton("Overwrite Current Version", QMessageBox. AcceptRole)
        option_3 = message_box.addButton("Run Flipbook Without Saving", QMessageBox.AcceptRole)
        option_4 = message_box.addButton("Cancel", QMessageBox.RejectRole)
        
        message_box.setDefaultButton(option_1)

        new_path_list = [export_new_path, save_next_ver_to_flipbook_file]
        current_path_list = [export_new_path, save_next_ver_to_flipbook_file]

        #print(save_path)
        if hou.hipFile.hasUnsavedChanges():
            #reply = QMessageBox.question(self, "Question", "You have Unsaved Changes. Do you want to Save before Running the Flipbook?",
            #                             QMessageBox.Yes | QMessageBox.No, QMessageBox.Yes)
            message_box.exec_()
            
            if message_box.clickedButton() == option_1:
                code_executed = False

                for new_path_index in new_path_list:
                    hou.hipFile.save(new_path_index, False)

                code_executed = True

                hou.ui.triggerUpdate()
                hou.ui.waitUntil(lambda: code_executed)
                self.swap_camera_to_run_flipbook_settings()
                #self.call_progress_bar(str(self.flipbook_line_edit.text()))

            elif message_box.clickedButton() == option_2:
                code_executed = False

                for cur_path_index in current_path_list:
                    hou.hipFile.save(cur_path_index, False)

                code_executed = True

                hou.ui.triggerUpdate()
                hou.ui.waitUntil(lambda: code_executed)
                self.swap_camera_to_run_flipbook_settings()
                #self.call_progress_bar(str(self.flipbook_line_edit.text()))

            elif message_box.clickedButton() == option_3:
                code_executed = False
                hou.hipFile.save(save_current_ver_to_flipbook_file, False)
                code_executed = True
                self.swap_camera_to_run_flipbook_settings()
                #self.call_progress_bar(str(self.flipbook_line_edit.text()))

            elif message_box.clickedButton() == option_4:
                pass
        else:
            self.swap_camera_to_run_flipbook_settings()
            output_bool = True if len(hou.text.expandString(self.flipbook_line_edit.text())) > 0 and os.path.exists(hou.text.expandString(self.flipbook_line_edit.text())) else False
            if output_bool:
                #self.call_progress_bar(str(self.flipbook_line_edit.text()))
                pass



########################################################################################
# Handle Text and Fit to Top Left
    def generate_text(self, text, font_size, shadow_color = (0, 0, 0), blur_radius=2):

        settings_file = self.flipbook_video_format_selector.get_json_path(self.flipbook_line_edit.text())
        print(settings_file)

        info, tempdir = self.read_json_settings(settings_file)

        font = ImageFont.truetype(font=ImageFont.load_default(), size=font_size)

        draw = ImageDraw.Draw(Image.new('RGBA', (1, 1)))    #Create temp image to get text size
        text_width, text_height = draw.textsize(text,font)

        #Calculate Image size to fit the text and shadow
        image_width = text_width + 3 * blur_radius
        image_height = text_height + 3 * blur_radius

        #Create new image with RGBA Mode (Background based on Alpha)
        alpha = 0
        image = Image.new("RGBA", (image_width, image_height), (0, 0, 0, alpha))

        #Recreate the font and draw it
        #if os.path.exists(font_name):
        #    font = ImageFont.truetype(font_name, font_size)
        #else:
        #    font = ImageFont.load_default()
        
        draw = ImageDraw.Draw(image)

        x = blur_radius
        y = blur_radius

        #Draw Drop Shadow for Text
        Image.new()
        shadow = Image.new('RGBA', image.size)
        shadow_draw = ImageDraw.Draw(shadow)
        shadow_draw.text((x + blur_radius, y + blur_radius), text, font=font, fill=shadow_color)
        shadow = shadow.filter(ImageFilter. GaussianBlur(blur_radius))
        image.paste(shadow, (0,0), shadow)

        #Draw the Text on top of the shadow

        draw.text((x, y), text, font=font, fill = (255, 255, 255))

        return image

    def save_text_to_image(self):

        start_frame = int(hou.text.expandString(self.flipbook_start_frame_line_edit.text()))
        end_frame = int(hou.text.expandString(self.flipbook_end_frame_line_edit.text()))

        name = hou.text.expandString(self.name_line_edit.text())
        #text_path = hou.text.expandString(self.flipbook_line_edit.text())
        
        image_format = "png"     #self.flipbook_format_select_combobox.currentText()

        json_path = self.flipbook_video_format_selector.get_json_path(self.flipbook_line_edit.text())

        info, tempdir = self.read_json_settings(json_path)

        cur_ver = "".join(["v",self.ver_select_combobox.currentText()])

        font_size = info[font_size]

        padzero = 4
        comment_text = info["comment_text"]
        comment = info['comment']
        if comment and comment_text and self.add_comment_checkbox.isChecked():

            #camera_node = hou.ui.paneTabOfType(hou.paneTabType.SceneViewer).curViewport().camera()
            camera_node = self.camera_line_edit.text().split("/")[-1]
            print("Current Camera Evaluated is: {}".format(camera_node))    #Debug
            if camera_node:
                #comment_text = str(comment_text).replace('[shotcam]', camera_node.name())
                comment_text = str(comment_text).replace('[shotcam]', camera_node)
            else:
                comment_text = str(comment_text).replace('[shotcam]', "")

            print("Incoming Comment Text for Camera is: {}".format(comment_text))   #Debug

            for frame in range((end_frame - start_frame) + 1):
                path_dir = "{}/{}/{}_{}.{}".format(tempdir, cur_ver, name, str(frame).zfill(padzero), image_format)
                print("Output Directory: {}".format(path_dir))  #Debug
                display_text_info = hou.expandStringAtFrame(comment_text, frame)

                comment_list = list()
                if '\n' in comment_text:
                    for line in comment_text.split('\n'):
                        text = hou.expandStringAtFrame(line, frame + start_frame)                         


                #Keep only first two decimal places of the float number
                matched = re.search('\d + \d*)\d', display_text_info)

                if matched:
                    float_number = matched.group(1)
                    formatted_float = str(round(float(float_number), 2))
                    text = text.replace(float_number, formatted_float)
                comment_list.append(text)

                text = '\n'.join(comment_list)
        
        result_image = self.generate_text(text, font_size)
        result_image.save(path_dir)

        return result_image
    
########################################################################################
# Encoder
    def organize_temp_dir_files(self):

        json_path = self.flipbook_video_format_selector.get_json_path(self.flipbook_line_edit.text())

        info, tempdir = self.read_json_settings(json_path)

        if self.flipbook_video_format_selector.cur_video_format == 'mp4' or self.flipbook_video_format_selector.cur_video_format == '.avi':
            encoder = 'libx264'
        if self.flipbook_video_format_selector.cur_video_format == 'mov':
            encoder = 'prores'

        cur_ver = "".join(["v",self.ver_select_combobox.currentText()])
        name = hou.text.expandString(self.name_line_edit.text())
        frame = hou.text.expandString("$F4")
        flipbook_format = self.flipbook_format_select_combobox.currentText()

#evaluate all options for video formats

        video_file_count = 1
        video_files = os.listdir(input_path)
        for video_file in video_files:
            if video_file.lower().endswith(".mp4") or video_file.lower().endswith(".mov") or video_file.lower().endswith(".avi"):
                video_file_count += 1

        version = video_file_count

        video_name = "".join([name, "_v{}".format(version)])

        video_format = str(self.video_format_select_combobox.currentText())

        #video_path = "".join([input_path, video_name, ".", video_format])   ############# Progressed here so far
        video_path = self.video_line_edit.text()

        #default_font = ""

        ffmpeg_path = hou.text.expandString(self.ffmpeg_line_edit.text())

        flipbook_path = hou.text.expandString(self.flipbook_line_edit.text())

        name = hou.text.expandString(self.name_line_edit.text())

        input_path = hou.text.expandString(self.video_line_edit.text())

        comment = info['comment']
        comment_text = info['comment_text']

        if comment and comment_text and self.add_comment_checkbox.isChecked():
            path_to_check = "".join([tempdir, "/", cur_ver])
            background_files = [os.path.join(path_to_check, file) for file in os.listdir(path_to_check) if file.lower().endswith(flipbook_format)]
            foreground_files = [os.path.join(path_to_check, file) for file in os.listdir(path_to_check) if file.lower().endswith('.png')]

            background_files.sort()
            foreground_files.sort()

            fps = hou.text.expandString(self.fps_line_edit.text())

    def overlay_and_save_frames(self, background_file, foreground_file, output_file):
        background = Image.open(background_file).convert('RGBA')
        foreground = Image.open(foreground_file).convert('RGBA')

        #paste foreground and background into a new image
        combined = Image.new('RGBA', background.size)
        combined.paste(background, (0, 0))
        combined.paste(foreground, (10, 10), foreground)

        #save combined image
        combined.save(output_file)

    def run_all_image_ops(self):
        threads = list()

        #Multithread overlay and save frame
        
########################################################################################
# Update Progress Bar
    def call_progress_bar(self, path):

        start_frame = int(hou.text.expandString(self.flipbook_start_frame_line_edit.text()))
        end_frame = int(hou.text.expandString(self.flipbook_end_frame_line_edit.text()))
        #start_frame = 1 #Debug
        #end_frame = 240 #Debug

        self.thread = ProgressBarThread()
        self.thread.update_progress.connect(self.update_progress_bar)
        self.thread.finished.connect(self.update_progress_bar_finished)
        
        self.load_progress_bar.setValue(0)
        self.thread.run(path, start_frame, end_frame)
    
    def update_progress_bar(self, value):
        self.load_progress_bar.setValue(value)

    def update_progress_bar_finished(self):
        #self.load_progress_bar.setValue(0)
        self.thread = None




dialog = FlipBookerWindow()
dialog.show()

sys.exit(dialog)
